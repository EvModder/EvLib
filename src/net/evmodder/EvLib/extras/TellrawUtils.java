package net.evmodder.EvLib.extras;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;
import javax.annotation.Nonnull;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Player;
import org.bukkit.scoreboard.Objective;

public class TellrawUtils{
	public enum ClickEvent{// Descriptions below are from https://minecraft.gamepedia.com/Raw_JSON_text_format
		OPEN_URL,// opens value as a URL in the player's default web browser
		OPEN_FILE,// opens the value file on the user's computer
		//NOTE: "open_file" is  used in messages generated by the game (e.g. on taking a  screenshot) and cannot be used in commands or signs.
		RUN_COMMAND,// has value entered in chat as though the player typed it themselves.
					// This can be used to run commands, provided the player has the  required permissions
		CHANGE_PAGE,// can be used only in written books
		SUGGEST_COMMAND,// similar to "run_command" but it cannot be used in a written book, the text appears only in the player's chat
						// input and it is not automatically entered. Unlike insertion, this replaces the existing contents of the chat input
		COPY_TO_CLIPBOARD;// copy the value to the clipboard

		@Override public String toString(){return name().toLowerCase();}
	}
	public enum HoverEvent{
		SHOW_TEXT,// shows raw JSON text
		SHOW_ITEM,// shows the tooltip of an item that can have NBT tags
		SHOW_ENTITY;// shows an entity's name, possibly its type, and its UUID
//		SHOW_ACHIEVEMENT;// shows advancement or statistic
//		//tellraw @a {"text":"test","hoverEvent":{"action":"show_achievement","value":"minecraft:adventure/arbalistic"}}//CURRENT DOESNT WORK

		@Override public String toString(){return name().toLowerCase();}
	}
	public final static class TextClickAction{
		final ClickEvent event;
		final String value;
		public TextClickAction(@Nonnull ClickEvent event, @Nonnull String value){this.event = event; this.value = value;}
		@Override public boolean equals(Object other){
			return other != null && other instanceof TextClickAction
					&& ((TextClickAction)other).event.equals(event) && ((TextClickAction)other).value.equals(value);
		}
	}
	public final static class TextHoverAction{
		final HoverEvent event;
		final String value;
		public TextHoverAction(@Nonnull HoverEvent event, @Nonnull String value){this.event = event; this.value = value;}
		@Override public boolean equals(Object other){
			return other != null && other instanceof TextHoverAction
					&& ((TextHoverAction)other).event.equals(event) && ((TextHoverAction)other).value.equals(value);
		}
	}

	public enum Keybind{
		ATTACK("key.attack"), USE("key.use"),
		FORWARD("key.forward"), BACK("key.back"), LEFT("key.left"), RIGHT("key.right"), JUMP("key.jump"), SNEAK("key.sneak"), SPRINT("key.sprint"),
		OPEN_INVENTORY("key.inventory"), PICK_ITEM("key.pickItem"), DROP("key.drop"), SWAP_HANDS("key.swapHands"), OPEN_ADVANCEMENTS("key.advancements"),
		HOTBAR_1("key.hotbar.1"), HOTBAR_2("key.hotbar.2"), HOTBAR_3("key.hotbar.3"), HOTBAR_4("key.hotbar.4"), HOTBAR_5("key.hotbar.5"),
		HOTBAR_6("key.hotbar.6"), HOTBAR_7("key.hotbar.7"), HOTBAR_8("key.hotbar.8"), HOTBAR_9("key.hotbar.9"),
		CHAT("key.chat"), PLAYERLIST("key.playerlist"), COMMAND("key.command"),
		SCREENSHOT("key.screenshot"), FULLSCREEN("key.fullscreen"),
		TOGGLE_PERSPECTIVE("key.togglePerspective"), SMOOTH_CAMERA("key.smoothCamera"), SPECTATOR_OUTLINES("key.spectatorOutlines"),
		SAVE_TOOLBAR("key.saveToolbarActivator"), LOAD_TOOLBAR("key.loadToolbarActivator"),
		OPTIFINE_ZOOM("of.key.zoom");

		final String toString;
		Keybind(String toString){this.toString = toString;}
		@Override public String toString(){return toString;}
	};

	public enum Format{BOLD, ITALIC, UNDERLINED, STRIKETHROUGH, OBFUSCATED}
	public final static class FormatFlag{
		final Format format;
		final boolean value;
		public FormatFlag(@Nonnull Format format, boolean value){this.format = format; this.value = value;}
		@Override public String toString(){return new StringBuilder('"').append(format.toString().toLowerCase()).append("\":").append(value).toString();}
		@Override public boolean equals(Object other){
			return other != null && other instanceof FormatFlag && ((FormatFlag)other).format.equals(format) && ((FormatFlag)other).value == value;
		}
	}

	// From wiki: Content tags are checked in the order: text, translate, score, selector, keybind, nbt.
	public static abstract class Component{
		final private String insertion; // When the text is shift-clicked by a player, this string is inserted in their chat input.
		final private TextClickAction clickAction;
		final private TextHoverAction hoverAction;
		final private String color;
		final private FormatFlag[] formats;
		final boolean hasProperties;

		String getInsertion(){return insertion;}
		TextClickAction getClickAction(){return clickAction;}
		TextHoverAction getHoverAction(){return hoverAction;}
		String getColor(){return color;}
		FormatFlag[] getFormats(){return formats;}

		private Component(String insertion, TextClickAction clickAction, TextHoverAction hoverAction, String color, FormatFlag... formats){
			this.insertion = insertion; this.clickAction = clickAction; this.hoverAction = hoverAction; this.color = color; this.formats = formats;
			hasProperties = insertion != null || clickAction != null || hoverAction != null || color != null || (formats != null && formats.length > 0);
			if(Arrays.stream(formats).map(formatFlag -> formatFlag.format).distinct().count() < formats.length){
				throw new IllegalArgumentException("Multiple FormatFlags in a Component cannot reference the same Format type");
			}
		}
		private Component(){this(/*insertion=*/null, /*clickAction=*/null, /*hoverAction=*/null, /*color=*/null, /*formats=*/null);}

		String getProperties(){
			if(!hasProperties) return "";
			StringBuilder builder = new StringBuilder();
			if(insertion != null) builder.append(",\"insertion\":\"").append(TextUtils.escape(insertion, "\"","\n")).append('"');
			if(color != null) builder.append(",\"color\":\"").append(color).append('"');
			if(formats != null && formats.length > 0) builder.append(',')
									.append(Arrays.stream(formats).map(FormatFlag::toString).collect(Collectors.joining(",")));
			if(clickAction != null) builder.append(",\"clickEvent\":{\"action\":\"").append(clickAction.event)
									.append("\",\"value\":\"").append(TextUtils.escape(clickAction.value, "\"","\n")).append("\"}");
			if(hoverAction != null) builder.append(",\"hoverEvent\":{\"action\":\"").append(hoverAction.event)
									.append("\",\"value\":\"").append(TextUtils.escape(hoverAction.value, "\"","\n")).append("\"}");
			return builder.toString();// Starts with a comma, formerly was builder.substring(1);
		}
		boolean samePropertiesAs(Component other){
			return (getInsertion() == null ? other.getInsertion() == null : getInsertion().equals(other.getInsertion())) &&
					(getClickAction() == null ? other.getClickAction() == null : getClickAction().equals(other.getClickAction())) &&
					(getHoverAction() == null ? other.getHoverAction() == null : getHoverAction().equals(other.getHoverAction())) &&
					(getColor() == null ? other.getColor() == null : getColor().equals(other.getColor())) &&
					(getFormats() == null ? other.getFormats() == null : (other.getFormats() != null && Arrays.equals(getFormats(), other.getFormats()))) &&
					(this instanceof SelectorComponent == other instanceof SelectorComponent) &&
					(!(this instanceof SelectorComponent) || ((SelectorComponent)this).selector.equals(((SelectorComponent)other).selector));
		}
		// True if @other doesn't override any of the properties of this component
		boolean noOverridingProperties(Component other){
			return (other.getInsertion() == null || other.getInsertion().equals(getInsertion())) &&
					other.getClickAction() == null || other.getClickAction().equals(getClickAction()) &&
					other.getHoverAction() == null || other.getHoverAction().equals(getHoverAction()) &&
					other.getColor() == null || other.getColor().equals(getColor()) &&
					(other.getFormats() == null || other.getFormats().length == 0 ||
						(getFormats() != null && Arrays.asList(getFormats()).containsAll(Arrays.asList(other.getFormats())))) &&
					(this instanceof SelectorComponent == other instanceof SelectorComponent) &&
					(!(this instanceof SelectorComponent) || ((SelectorComponent)this).selector.equals(((SelectorComponent)other).selector));
		}

		public abstract String toString();
		public abstract String toPlainText();
	};
	public final static class RawTextComponent extends Component{
		final String text;
		public RawTextComponent(@Nonnull String text){this.text = text;}
		public RawTextComponent(@Nonnull String text, String insert, TextClickAction click, TextHoverAction hover, String color, FormatFlag... formats){
			super(insert, click, hover, color, formats);
			this.text = text;
		}
		//tellraw @a "test"
		//tellraw @a {"text":"test"}
		//tellraw @a {"text":"test","insertion":"hi there"}

		@Override public String toPlainText(){return text;}
		@Override public String toString(){
			String escapedText = TextUtils.escape(text, "\"","\n");
			return !hasProperties
					? new StringBuilder().append('"').append(escapedText).append('"').toString()
					: new StringBuilder("{\"text\":\"").append(escapedText).append('"').append(getProperties()).append('}').toString();
		}
	}
	public final static class TranslationComponent extends Component{
		final String jsonKey;
		final Component[] with; // Used to replace "%s" placeholders in the translation text.
		public TranslationComponent(@Nonnull String jsonKey){this.jsonKey = jsonKey; with = null;} //TODO: validate json key?
		public TranslationComponent(@Nonnull String jsonKey, @Nonnull Component... with){this.jsonKey = jsonKey; this.with = with;}
		public TranslationComponent(@Nonnull String jsonKey, Component[] with,
				String insert, TextClickAction click, TextHoverAction hover, String color, FormatFlag... formats){
			super(insert, click, hover, color, formats);
			this.jsonKey = jsonKey;
			this.with = with;
		}
		//tellraw @a {"translate":"multiplayer.player.joined","with":["EvDoc", "unused"]} -> en_us.json: "%s joined the game"

		@Override public String toPlainText(){
			// This is ONLY correct when the key is invalid/unknown to the client!
			return String.format(jsonKey, Arrays.stream(with).map(Component::toPlainText).toArray());
			//TODO: EN_US.json(or server default) -> LOOKUP ASSOCIATED VALUE and return that instead!
		}
		@Override public String toString(){
			StringBuilder builder = new StringBuilder().append("{\"translate\":\"").append(jsonKey).append('"');
			if(with != null && with.length > 0) builder.append(",\"with\":[").append(
					Arrays.stream(with).map(Component::toString).collect(Collectors.joining(","))).append(']');
			return builder.append(getProperties()).append('}').toString();
		}
	}
	public final static class ScoreComponent extends Component{
		final Object selector;
		final Objective objective;
		String value; // Optional; overwrites output of score selector
		public ScoreComponent(@Nonnull Object selector, @Nonnull Objective objective){this.selector = selector; this.objective = objective;}
		public ScoreComponent(@Nonnull String name, @Nonnull Objective objective){this.selector = name; this.objective = objective;}
		public ScoreComponent(@Nonnull Object selector, @Nonnull Objective objective,
				String insert, TextClickAction click, TextHoverAction hover, String color, FormatFlag... formats){
			super(insert, click, hover, color, formats);
			this.selector = selector;
			this.objective = objective;
		}
		//tellraw @a {"score":{"name":"@p","objective":"levels","value":"3333"}}

		@Override public String toPlainText(){
			String name = null;
			try{
				UUID uuid = UUID.fromString(selector.toString());
				name = Bukkit.getEntity(uuid).getName();
			}
			catch(IllegalArgumentException ex){};
			try{
				Class<?> clazz = Class.forName("net.evmodder.EvLib.extras.SelectorUtils.Selector");
				@SuppressWarnings("unchecked")
				Collection<Entity> entities = (Collection<Entity>)clazz.getMethod("resolve").invoke(selector);
				if(entities.size() > 1) return "ERROR: more than 1 entity matched with score selector!";
				if(entities.isEmpty()) return "";
				name = entities.iterator().next().getName();
			}
			catch(Exception ex){name = selector.toString();}
			if(name == null) return "";
			return ""+objective.getScore(name).getScore();
		}
		@Override public String toString(){
			StringBuilder builder = new StringBuilder().append("\"score\":{\"name\":\"")
					.append(selector.toString()).append("\",\"objective\":\"").append(objective.getName()).append('"');
			if(value != null) builder.append(",\"value\":\"").append(TextUtils.escape(value, "\"","\n")).append('"');
			return builder.append('}').append(getProperties()).append('}').toString();
		}
	}
	public final static class SelectorComponent extends Component{
//		final Selector selector;
		final Object selector;
		final boolean useDisplayName;
		public SelectorComponent(@Nonnull Object selector){this.selector = selector; this.useDisplayName = true;}
		public SelectorComponent(@Nonnull UUID uuid){this.selector = uuid; this.useDisplayName = true;}
		public SelectorComponent(@Nonnull Object selector, boolean useDisplayName){this.selector = selector; this.useDisplayName = useDisplayName;}
		public SelectorComponent(@Nonnull UUID uuid, boolean useDisplayName){this.selector = uuid; this.useDisplayName = useDisplayName;}
//		public SelectorComponent(@Nonnull SelectorType type, @Nonnull SelectorArgument...arguments){this.selector = new Selector(type, arguments);}
		//tellraw @a {"selector":"@a"}

		private static String getNormalizedName(Entity entity, boolean useDisplayName){
			if(entity instanceof Player && useDisplayName) return ((Player)entity).getDisplayName();
			return entity.getName() != null ? entity.getName() : TextUtils.getNormalizedName(entity.getType());
		}
		@Override public String toPlainText(){
			Collection<String> names = null;
			try{
				UUID uuid = selector instanceof UUID ? (UUID)selector : UUID.fromString(selector.toString());
				names = Arrays.asList(getNormalizedName(Bukkit.getEntity(uuid), useDisplayName));
			}
			catch(IllegalArgumentException ex){};
			if(names == null) try{
				Class<?> clazz = Class.forName("net.evmodder.EvLib.extras.SelectorUtils.Selector");
				@SuppressWarnings("unchecked")
				Collection<Entity> entities = (Collection<Entity>)clazz.getMethod("resolve").invoke(selector);
				names = entities.stream().filter(e -> e != null).map(e -> getNormalizedName(e, useDisplayName)).collect(Collectors.toList());
			}
			catch(Exception ex){names = Arrays.asList(selector.toString());}
			return String.join(ChatColor.GRAY+", "+ChatColor.RESET, names);
		}
		@Override public String toString(){
			return new StringBuilder().append("{\"selector\":\"").append(TextUtils.escape(selector.toString(), "\"","\n"))
					.append(getProperties()).append("\"}").toString();
		}
	}
	public final static class KeybindComponent extends Component{
		final Keybind keybind;
		public KeybindComponent(@Nonnull Keybind keybind){this.keybind = keybind;}
		//tellraw @a {"keybind":"of.key.zoom"}
		@Override public String toPlainText(){return keybind.toString();}//TODO: KEY SETTING NAME HERE if possible?
		@Override public String toString(){
			return new StringBuilder().append("{\"keybind\":\"").append(keybind).append('"').append(getProperties()).append('}').toString();
		}
	}

	public final static class ListComponent extends Component{
		@Override String getInsertion(){return components.isEmpty() ? null : components.get(0).getInsertion();}
		@Override TextClickAction getClickAction(){return components.isEmpty() ? null : components.get(0).getClickAction();}
		@Override TextHoverAction getHoverAction(){return components.isEmpty() ? null : components.get(0).getHoverAction();}
		@Override String getColor(){return components.isEmpty() ? null : components.get(0).getColor();}
		@Override FormatFlag[] getFormats(){return components.isEmpty() ? null : components.get(0).getFormats();}
		Component last = null;
		List<Component> components;
		public ListComponent(@Nonnull Component...components){
			this.components = new ArrayList<>();
			for(Component comp : components) addComponent(comp);
		}
		//TODO: make this NOT public?
		public List<Component> getComponents(){return components;}

		private RawTextComponent copyWithNewText(@Nonnull RawTextComponent comp, @Nonnull String text){
			return new RawTextComponent(text, comp.getInsertion(), comp.getClickAction(), comp.getHoverAction(), comp.getColor(), comp.getFormats());
		}
		public boolean addComponent(@Nonnull Component component){
			if(component.toPlainText().isEmpty()) return false;
			if(component instanceof RawTextComponent){
				if(ChatColor.stripColor(component.toPlainText()).isEmpty()) return false;
				if(last != null && last instanceof RawTextComponent && last.noOverridingProperties(component)){
					components.remove(components.size()-1);
					components.add(last = copyWithNewText((RawTextComponent)last, last.toPlainText() + component.toPlainText()));
					return true;
				}
			}
			if(component instanceof ListComponent){
				// We can safely flatten nested TellrawBlobs IFF they don't override any of the parent's "group properties"
				if(noOverridingProperties(component)){
					for(Component comp : ((ListComponent)component).getComponents()) addComponent(comp);
					return true;
				}
				return components.add(last = component);
			}
			return components.add(last = component);
		}
		public void addComponent(@Nonnull String text){addComponent(new RawTextComponent(text));}

		/**
		 * Loops through all RawTextComponents in this instance and replaces all occurances of @textToReplace with the @replacement component
		 * @param textToReplace The simple text from inside a RawTextComponent to search for
		 * @param replacement The component substituted in place of each instance of matching text
		 * @return true if one or more replacements occurred
		 */
		public boolean replaceRawDisplayTextWithComponent(@Nonnull final String textToReplace, @Nonnull final Component replacement){
			if(textToReplace.isEmpty()) return false;
			boolean updated = false;
			for(int i=0; i<components.size(); ++i){
				Component comp = components.get(i);
				if(comp instanceof ListComponent){
					if(((ListComponent)comp).replaceRawDisplayTextWithComponent(textToReplace, replacement)) updated = true;
				}
				if(comp instanceof RawTextComponent == false) continue;
				RawTextComponent txComp = (RawTextComponent) comp;
				final String text = txComp.toPlainText();
				if(text.contains(textToReplace) == false) continue;
				boolean replacementIsRawText = replacement instanceof RawTextComponent;

				if(replacementIsRawText && txComp.noOverridingProperties(replacement)){
					components.set(i, copyWithNewText(txComp, text.replace(textToReplace, ((RawTextComponent)replacement).toPlainText())));
					continue;
				}
				int matchIdx = text.indexOf(textToReplace);
				String textBefore = text.substring(0, matchIdx);
				String textAfter = text.substring(matchIdx+textToReplace.length());
				boolean emptyBefore = (replacementIsRawText ? ChatColor.stripColor(textBefore) : textBefore).isEmpty();
				boolean emptyAfter = (replacementIsRawText ? ChatColor.stripColor(textAfter) : textAfter).isEmpty();
				// Necessary to prevent overriding this ListComponent's group properties
				if(i == 0 && emptyBefore && !this.samePropertiesAs(replacement)){components.add(0, copyWithNewText(txComp, "")); i = 1;}

				Component replacementInst = replacement;
				if(replacementIsRawText){
					String replacementText = replacement.toPlainText();
					if(emptyBefore) replacementInst = copyWithNewText((RawTextComponent)replacement, textBefore + replacementText);
					if(emptyAfter) replacementInst = copyWithNewText((RawTextComponent)replacement, replacementText + textAfter);
				}
				if(emptyBefore && emptyAfter){
					if(i == components.size()-1) last = replacementInst;
					components.set(i, replacementInst);
				}
				else if(emptyBefore){
					components.set(i, copyWithNewText(txComp, textAfter));
					components.add(i, replacementInst);
				}
				else if(emptyAfter){
					components.set(i, new RawTextComponent(textBefore));
					if(++i == components.size()) components.add(last = replacementInst);
					else components.add(i, replacementInst);
				}
				else{
					components.set(i, copyWithNewText(txComp, textBefore));
					RawTextComponent textAfterComp = copyWithNewText(txComp, textAfter);
					if(++i == components.size()){components.add(replacementInst); components.add(last = textAfterComp);}
					else{components.add(i, textAfterComp); components.add(i, replacementInst);}
				}
				updated = true;
			}
			return updated;
		}

		@Override public String toPlainText(){
			StringBuilder builder = new StringBuilder();
			for(Component comp : components) builder.append(comp.toPlainText());
			return builder.toString();
		}
		@Override public String toString(){
			while(last instanceof RawTextComponent && ChatColor.stripColor(last.toPlainText()).isEmpty()){
				components.remove(components.size()-1);
				last = components.isEmpty() ? null : components.get(components.size()-1);
			}
			switch(components.size()){
				case 0: return "\"\"";
				case 1: return components.get(0).toString();
				default: return new StringBuilder().append('[').append(
							components.stream().map(Component::toString).collect(Collectors.joining(","))
						).append(']').toString();
			}
		}
	}
/*
	private final static String getColorName(char[] msg, int i){
		switch(msg[i]){
			case '0': return "black";
			case '1': return "dark_blue";
			case '2': return "dark_green";
			case '3': return "dark_aqua";
			case '4': return "dark_red";
			case '5': return "dark_purple";
			case '6': return "gold";
			case '7': return "gray";
			case '8': return "dark_gray";
			case '9': return "blue";
			case 'a': return "green";
			case 'b': return "aqua";
			case 'c': return "red";
			case 'd': return "light_purple";
			case 'e': return "yellow";
			case 'f': return "white";
			case 'r': return "white";
			case 'x': return "#"+msg[i+2]+msg[i+4]+msg[i+6]+msg[i+8]+msg[i+10]+msg[i+12];
			default: return null;
		}
	}
	private final static FormatFlag getFormat(char ch){
		switch(ch){
			case 'l': return FormatFlag.BOLD_TRUE;
			case 'o': return FormatFlag.ITALIC_TRUE;
			case 'n': return FormatFlag.UNDERLINED_TRUE;
			case 'm': return FormatFlag.STRIKETHROUGH_TRUE;
			case 'k': return FormatFlag.OBFUSCATED_TRUE;
			default: return null;
		}
	}
	public final static TellrawBlob translateSpigotColorCodesToComponents(String textToTranslate){
		TellrawBlob blob = new TellrawBlob();
		String currentColor = "r"; // 
		HashSet<FormatFlag> currentFormats = new HashSet<>();// We can simplify by only storing <FORMAT>_TRUE values (if not-contains, assume false)

		Pattern pattern = Pattern.compile("ยง(?:[0-9a-fA-Fk-oK-O]|x(?:ยง[0-9a-fA-F]){6})");// Matches only valid colors, formats, and hex colors
		Matcher matcher = pattern.matcher(textToTranslate);
		int lastTextStart = 0;
		while(matcher.find()){
			String lastText = textToTranslate.substring(lastTextStart, matcher.start());
			FormatFlag newFormat = getFormat(matcher.group().charAt(1));
			if(newFormat != null){
				if(currentFormats.contains(newFormat))
				if(lastText.trim().isEmpty());
			}
			switch(matcher.group(1)){
				
			}
		}
		
//		char[] msg = textToTranslate.toCharArray();
//		for(int i=0; i<msg.length-1; ++i){
//			if(msg[i] != ChatColor.COLOR_CHAR) currentText.append(msg[i]);
//			else switch(msg[i+1]){
//				case 'l': bold = true;
//			}
//			if(colorPick){
//				String newColor = getColorName(msg, i);
//				String newFormat;
//				if(newColor == null)
//			}
//			else if(!(colorPick=(ch == ChatColor.COLOR_CHAR))) currentText.append(ch);
//			
//		}
		return blob;
	}*/
}