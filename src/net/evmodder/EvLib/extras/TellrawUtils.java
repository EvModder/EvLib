package net.evmodder.EvLib.extras;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.Server;
import org.bukkit.block.Banner;
import org.bukkit.block.BlockState;
import org.bukkit.block.Skull;
import org.bukkit.entity.Entity;
import org.bukkit.entity.EntityType;
import org.bukkit.entity.Player;
import org.bukkit.entity.Rabbit;
import org.bukkit.entity.TropicalFish;
import org.bukkit.entity.Villager;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.BlockStateMeta;
import org.bukkit.inventory.meta.BookMeta;
import org.bukkit.inventory.meta.PotionMeta;
import org.bukkit.inventory.meta.SkullMeta;
import org.bukkit.potion.PotionEffectType;
import org.bukkit.scoreboard.Objective;

public class TellrawUtils{
	public enum ClickEvent{// Descriptions below are from https://minecraft.gamepedia.com/Raw_JSON_text_format
		OPEN_URL,// opens value as a URL in the player's default web browser
		OPEN_FILE,// opens the value file on the user's computer
		//NOTE: "open_file" is  used in messages generated by the game (e.g. on taking a  screenshot) and cannot be used in commands or signs.
		RUN_COMMAND,// has value entered in chat as though the player typed it themselves.
					// This can be used to run commands, provided the player has the  required permissions
		CHANGE_PAGE,// can be used only in written books
		SUGGEST_COMMAND,// similar to "run_command" but it cannot be used in a written book, the text appears only in the player's chat
						// input and it is not automatically entered. Unlike insertion, this replaces the existing contents of the chat input
		COPY_TO_CLIPBOARD;// copy the value to the clipboard

		@Override public String toString(){return name().toLowerCase();}
	}
	public enum HoverEvent{
		SHOW_TEXT,// shows raw JSON text
		SHOW_ITEM,// shows the tooltip of an item that can have NBT tags
		SHOW_ENTITY;// shows an entity's name, possibly its type, and its UUID
//		SHOW_ACHIEVEMENT;// shows advancement or statistic
//		//tellraw @a {"text":"test","hoverEvent":{"action":"show_achievement","value":"minecraft:adventure/arbalistic"}}//CURRENT DOESNT WORK

		@Override public String toString(){return name().toLowerCase();}
	}
	public final static class TextClickAction{
		public final ClickEvent event;
		public final String value;
		public TextClickAction(ClickEvent event, String value){this.event = event; this.value = value;}
		@Override public boolean equals(Object other){
			return other != null && other instanceof TextClickAction
					&& ((TextClickAction)other).event.equals(event) && ((TextClickAction)other).value.equals(value);
		}
	}
	public final static class TextHoverAction{
		public final HoverEvent event;
		public final Component value;
		public TextHoverAction(HoverEvent event, Component value){this.event = event; this.value = value;}
		public TextHoverAction(HoverEvent event, String value){this.event = event; this.value = new RawTextComponent(value);}
		@Override public boolean equals(Object other){
			return other != null && other instanceof TextHoverAction
					&& ((TextHoverAction)other).event.equals(event) && ((TextHoverAction)other).value.equals(value);
		}
	}

	public enum Keybind{
		ATTACK("key.attack"), USE("key.use"),
		FORWARD("key.forward"), BACK("key.back"), LEFT("key.left"), RIGHT("key.right"), JUMP("key.jump"), SNEAK("key.sneak"), SPRINT("key.sprint"),
		OPEN_INVENTORY("key.inventory"), PICK_ITEM("key.pickItem"), DROP("key.drop"), SWAP_HANDS("key.swapHands"), OPEN_ADVANCEMENTS("key.advancements"),
		HOTBAR_1("key.hotbar.1"), HOTBAR_2("key.hotbar.2"), HOTBAR_3("key.hotbar.3"), HOTBAR_4("key.hotbar.4"), HOTBAR_5("key.hotbar.5"),
		HOTBAR_6("key.hotbar.6"), HOTBAR_7("key.hotbar.7"), HOTBAR_8("key.hotbar.8"), HOTBAR_9("key.hotbar.9"),
		CHAT("key.chat"), PLAYERLIST("key.playerlist"), COMMAND("key.command"),
		SCREENSHOT("key.screenshot"), FULLSCREEN("key.fullscreen"),
		TOGGLE_PERSPECTIVE("key.togglePerspective"), SMOOTH_CAMERA("key.smoothCamera"), SPECTATOR_OUTLINES("key.spectatorOutlines"),
		SAVE_TOOLBAR("key.saveToolbarActivator"), LOAD_TOOLBAR("key.loadToolbarActivator"),
		OPTIFINE_ZOOM("of.key.zoom");

		final String toString;
		Keybind(String toString){this.toString = toString;}
		@Override public String toString(){return toString;}
	};

	public enum Format{
		OBFUSCATED('k'), BOLD('l'), STRIKETHROUGH('m'), UNDERLINED('n'), ITALIC('o');
		final char toChar;
		Format(char toChar){this.toChar = toChar;}
//		char toChar(){return toChar;}
		static Format fromChar(char ch){
			switch(ch){
				case 'k': return Format.OBFUSCATED;
				case 'l': return Format.BOLD;
				case 'm': return Format.STRIKETHROUGH;
				case 'n': return Format.UNDERLINED;
				case 'o': return Format.ITALIC;
				default: throw new IllegalArgumentException("Unknown format char: "+ch);
			}
		}
	}

	// for toPlainText() on KeybindComponent and TranslateComponent, we fall back to using the NMS resolver
	private static Constructor<?> translateConstructor, translateConstructorWith, translateConstructorFallbackAndWith, keybindConstructor;
	private static Method chatMessageGetString, makeIChatMutableComponent = null;
	private static boolean nmsInitAttempted = false;
	private static boolean toPlainTextUseNMS(){
		return nmsInitAttempted ? chatMessageGetString != null : (nmsInitAttempted=true) && initChatMessageRefMethod();
	}
	private static boolean initChatMessageRefMethod(){
		boolean post_1_19 = false;
		Class<?> clazz, keybindClazz;
		try{clazz = keybindClazz = Class.forName("net.minecraft.network.chat.ChatMessage");}
		catch(ClassNotFoundException e0){
			try{
				Server server = Bukkit.getServer();
				String nmsVersion = server.getClass().getDeclaredMethod("getHandle").invoke(server).getClass().getName().split("\\.")[3];
				clazz = keybindClazz = Class.forName("net.minecraft.server."+nmsVersion+".ChatMessage");
			}
			catch(NullPointerException e3){return false;} // Unable to find nmsVersion -- indicates this is not running on a Bukkit server
			catch(NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalAccessException
					| IllegalArgumentException | InvocationTargetException e1){
				try{
					clazz = Class.forName("net.minecraft.network.chat.contents.TranslatableContents");
					keybindClazz = Class.forName("net.minecraft.network.chat.contents.KeybindContents");
					post_1_19 = true;
				}
				catch(ClassNotFoundException e2){return false;}
			}
		}
		try{
			// Get constructors
			try{ // pre 1.19.4
				keybindConstructor = keybindClazz.getConstructor(String.class);
				translateConstructor = clazz.getConstructor(String.class);
				translateConstructorWith = clazz.getConstructor(String.class, Object[].class);
			}
			catch(NoSuchMethodException e){/*bad1=true*/}
			try{ // post 1.19.4
				translateConstructorFallbackAndWith = clazz.getConstructor(String.class, String.class, Object[].class);
			}
			catch(NoSuchMethodException e){/*bad2=true*/}
			if(post_1_19){
				chatMessageGetString = Class.forName("net.minecraft.network.chat.IChatBaseComponent").getMethod("getString");
				Class<?> clazzComponentContents = Class.forName("net.minecraft.network.chat.ComponentContents");
				Class<?> clazzIChatMutableComponent = Class.forName("net.minecraft.network.chat.IChatMutableComponent");
				Class<?>[] params = new Class[]{clazzComponentContents};
				for(Method m : clazzIChatMutableComponent.getDeclaredMethods()){//findMethod
					if(!Modifier.isStatic(m.getModifiers())) continue;
					if(!m.getReturnType().equals(clazzIChatMutableComponent)) continue;
					if(!Arrays.equals(params, m.getParameterTypes())) continue;
					makeIChatMutableComponent = m;
					break;
				}
			}
			else chatMessageGetString = clazz.getMethod("getString");
		}
		catch(NoSuchMethodException | SecurityException | ClassNotFoundException e){return false;}
		return true;
	}

	// From wiki: Content tags are checked in the order: text, translate, score, selector, keybind, nbt.
	public static abstract class Component{
		final private String insertion; // When the text is shift-clicked by a player, this string is inserted in their chat input.
		final private TextClickAction clickAction;
		final private TextHoverAction hoverAction;
		final private String color;
		final private Map<Format, Boolean> formats;
		private String toString;
		final boolean hasProperties;

		/** Returns the insertion text of this component (when the component is shift-clicked by a player, this string is inserted in their chat input).
		 * @return the insertion text */
		String getInsertion(){return insertion;}
		/** Returns the ClickAction of this component.
		 * @return the click action */
		TextClickAction getClickAction(){return clickAction;}
		/** Returns the HoverAction of this component.
		 * @return the hover action */
		TextHoverAction getHoverAction(){return hoverAction;}
		/** Returns the color of this component.
		 * @return a String denoting the color */
		String getColor(){return color;}
		/** Returns the formats of this component.
		 * @return a Map<Format, Boolean> with true values for formats applied on this component */
		Map<Format, Boolean> getFormats(){return formats;}

		private Component(String insertion, TextClickAction clickAction, TextHoverAction hoverAction, String color, Map<Format, Boolean> formats){
			this.insertion = insertion; this.clickAction = clickAction; this.hoverAction = hoverAction; this.color = color; this.formats = formats;
			hasProperties = insertion != null || clickAction != null || hoverAction != null || color != null || (formats != null && formats.size() > 0);
		}
		private Component(){this(/*insertion=*/null, /*clickAction=*/null, /*hoverAction=*/null, /*color=*/null, /*formats=*/null);}

		String getProperties(){
			if(!hasProperties) return "";
			StringBuilder builder = new StringBuilder();
			if(insertion != null) builder.append(",\"insertion\":\"").append(TextUtils.escape(insertion, "\"","\n")).append('"');
			if(color != null) builder.append(",\"color\":\"").append(color).append('"');
			if(formats != null && !formats.isEmpty()){
				builder.append(',').append(
						formats.entrySet().stream()
						.map(e -> new StringBuilder().append('"').append(e.getKey().toString().toLowerCase()).append("\":").append(e.getValue()).toString())
						.collect(Collectors.joining(",")));
			}
			if(clickAction != null) builder.append(",\"clickEvent\":{\"action\":\"").append(clickAction.event)
									.append("\",\"value\":\"").append(TextUtils.escape(clickAction.value, "\"","\n")).append("\"}");
			if(hoverAction != null) builder.append(",\"hoverEvent\":{\"action\":\"").append(hoverAction.event)
									.append("\",\"value\":").append(hoverAction.value.toString()).append("}");
			return builder.toString();// Starts with a comma, formerly was builder.substring(1);
		}
		// Returns null if this component could NOT possibly be a Selector matching exactly 1 target
		UUID potentialSingleMatchSelector(){
			if(this instanceof ListComponent && !((ListComponent)this).isEmpty()){
				return ((ListComponent)this).components.get(0).potentialSingleMatchSelector();
			}
			if(this instanceof SelectorComponent == false) return null;
			Object selector = ((SelectorComponent)this).selector;
			try{
				UUID uuid = selector instanceof UUID ? (UUID)selector : UUID.fromString(selector.toString());
				if(Bukkit.getEntity(uuid) != null) return uuid;
			}
			catch(IllegalArgumentException ex){};
			try{
				Class<?> clazz = Class.forName("net.evmodder.EvLib.extras.SelectorUtils.Selector");
				@SuppressWarnings("unchecked")
				Collection<Entity> entities = (Collection<Entity>)clazz.getMethod("resolve").invoke(selector);
				entities.removeIf(e -> e == null);
				if(entities.size() == 1) return entities.iterator().next().getUniqueId();
			}
			catch(Exception ex){return UUID.randomUUID();}// assume this matches an unknown single entity
			return null;
		}
		boolean samePropertiesAs(Component other){
			return (getInsertion() == null ? other.getInsertion() == null : getInsertion().equals(other.getInsertion())) &&
					(getClickAction() == null ? other.getClickAction() == null : getClickAction().equals(other.getClickAction())) &&
					(getHoverAction() == null ? other.getHoverAction() == null : getHoverAction().equals(other.getHoverAction())) &&
					(getColor() == null ? other.getColor() == null : getColor().equals(other.getColor())) &&
					(
						(getFormats() == null || getFormats().isEmpty()) ? (other.getFormats() == null || other.getFormats().isEmpty())
						: (other.getFormats() != null &&
							getFormats().entrySet().containsAll(other.getFormats().entrySet()) &&
							other.getFormats().entrySet().containsAll(getFormats().entrySet()))
					) &&
					(potentialSingleMatchSelector() == null ? other.potentialSingleMatchSelector() == null
						: potentialSingleMatchSelector().equals(other.potentialSingleMatchSelector()));
		}
		boolean overridesAllPropertiesOf(Component other){
			return (other.getInsertion() == null || getInsertion() != null) &&
					(other.getClickAction() == null || getClickAction() != null) &&
					(other.getHoverAction() == null || getHoverAction() != null) &&
					(other.getColor() == null || getColor() != null) &&
					(other.getFormats() == null || other.getFormats().isEmpty() ||
						(getFormats() != null && getFormats().keySet().containsAll(other.getFormats().keySet()))) &&
					(potentialSingleMatchSelector() == null) == (other.potentialSingleMatchSelector() == null);
		}
		// True if @other doesn't override any of the properties of this component
		boolean isPropertiesSupersetOf(Component other){
			return (other.getInsertion() == null || other.getInsertion().equals(getInsertion())) &&
					(other.getClickAction() == null || other.getClickAction().equals(getClickAction())) &&
					(other.getHoverAction() == null || other.getHoverAction().equals(getHoverAction())) &&
					(other.getColor() == null || other.getColor().equals(getColor())) &&
					(other.getFormats() == null || other.getFormats().isEmpty() ||
						(getFormats() != null && getFormats().entrySet().containsAll(other.getFormats().entrySet()))) &&
					(other.potentialSingleMatchSelector() == null || other.potentialSingleMatchSelector().equals(potentialSingleMatchSelector()));
		}

		protected abstract String toStringInternal();
		/** Returns a JSON string built from this component suitable for use in commands/tellraw.
		 * @return a formatted JSON String representing this component */
		@Override final public String toString(){return toString == null ? (toString = toStringInternal()) : toString;}
		/** Returns what this component would appear as (in plain text) if parsed by Minecraft's JSON/tellraw resolver.
		 * @return a String representing the resolved text of this component */
		public abstract String toPlainText();
		abstract Component copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats);
	};
	public final static class RawTextComponent extends Component{
		final String text;
		String getRawText(){return text;}
		public RawTextComponent(String text){this.text = text;}
		public RawTextComponent(String text, String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			super(insert, click, hover, color, formats);
			this.text = text;
		}
		public RawTextComponent(String text, TextClickAction click){
			this(text, /*insert=*/null, click, /*hover=*/null, /*color=*/null, /*formats=*/null);
		}
		public RawTextComponent(String text, TextHoverAction hover){
			this(text, /*insert=*/null, /*click=*/null, hover, /*color=*/null, /*formats=*/null);
		}
		//tellraw @a "test"
		//tellraw @a {"text":"test"}
		//tellraw @a {"text":"test","insertion":"hi there"}

		@Override public String toPlainText(){
			String color = getColor();
			if(color == null) color = "";
			else{
				try{color = ""+ChatColor.valueOf(color.toUpperCase());}
				catch(IllegalArgumentException ex){color = TextUtils.translateAlternateColorCodes('&', '&'+color);}
			}
			String formats = getFormats() == null ? "" : getFormats().entrySet().stream().filter(e -> e.getValue())
					.map(e -> ""+ChatColor.COLOR_CHAR+e.getKey().toChar).collect(Collectors.joining());
			return color+formats+text;
		}
		@Override protected String toStringInternal(){
			String escapedText = TextUtils.escape(text, "\"","\n");
			return !hasProperties
					? new StringBuilder().append('"').append(escapedText).append('"').toString()
					: new StringBuilder("{\"text\":\"").append(escapedText).append('"').append(getProperties()).append('}').toString();
		}
		@Override RawTextComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new RawTextComponent(text, insert, click, hover, color, formats);
		}
	}
	public final static class TranslationComponent extends Component{
		final String jsonKey, fallback;//fallback added in 1.19.4
		final Component[] with; // Used to replace "%s" placeholders in the translation text.
		public String getJsonKey(){return jsonKey;}
		public Component[] getWith(){return with;}
		public TranslationComponent(String jsonKey){this.jsonKey = jsonKey; this.fallback = null; with = null;}
		public TranslationComponent(String jsonKey, String fallback){this.jsonKey = jsonKey; this.fallback = fallback; with = null;}
		public TranslationComponent(String jsonKey, Component... with){this.jsonKey = jsonKey; this.fallback = null; this.with = with;}
		public TranslationComponent(String jsonKey, Component[] with,
				String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){//pre1.19.4
			super(insert, click, hover, color, formats);
			this.jsonKey = jsonKey;
			this.fallback = null;
			this.with = with;
		}
		public TranslationComponent(String jsonKey, String fallback, Component[] with,
				String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){//1.19.4+
			super(insert, click, hover, color, formats);
			this.jsonKey = jsonKey;
			this.fallback = jsonKey.equals(fallback) ? null : fallback;
			this.with = with;
		}
		//tellraw @a {"translate":"multiplayer.player.joined","with":["EvDoc", "unused"]} -> en_us.json: "%s joined the game"

		@Override public String toPlainText(){
			if(toPlainTextUseNMS()) try{
				Object translateComp = (with == null && translateConstructor != null)
						? translateConstructor.newInstance(jsonKey)
						: translateConstructorWith != null
							? translateConstructorWith.newInstance(jsonKey, Arrays.stream(with).map(Component::toPlainText).toArray())
							: translateConstructorFallbackAndWith.newInstance(jsonKey, fallback,
									with == null ? null : Arrays.stream(with).map(Component::toPlainText).toArray());
				if(makeIChatMutableComponent != null) translateComp = makeIChatMutableComponent.invoke(null, translateComp);
				return (String)(chatMessageGetString.invoke(translateComp));
			}
			catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException | InstantiationException e){}

			// This is ONLY correct when the key is invalid/unknown to the client
			return with == null
					? String.format(fallback != null ? fallback : jsonKey)
					: String.format(fallback != null ? fallback : jsonKey, Arrays.stream(with).map(Component::toPlainText).toArray());
		}
		ListComponent attemptConvertToListComp(){
			if(jsonKey.indexOf('%') == -1){ // Not a format str
				// TODO: Commented out this optimization because the key *might* be a valid key client-side
				//if(jsonKey.indexOf('.') == -1 && toPlainText().equals(jsonKey)) return new RawTextComponent(fallback != null ? fallback : jsonKey);
				return null;
			}

			final String formatText = (fallback != null ? fallback : jsonKey).replace("%%", "<thingie_cuz_lazy>");

			int nextSub = formatText.indexOf("%s");
			if(nextSub == -1) return null; // TODO: consider supporting formats besides "%s"
			ListComponent listComp = new ListComponent();
			int i = 0, textStart = 0;
			boolean isFirstComp = true;
			while(nextSub != -1){
				final String s = formatText.substring(textStart, nextSub).replace("<thingie_cuz_lazy>", "%");
				if(isFirstComp){
					isFirstComp = false;
					listComp.addComponent(new RawTextComponent(s, getInsertion(), getClickAction(), getHoverAction(), getColor(), getFormats()));
				}
				else if(!s.isEmpty()) listComp.addComponent(s);
				if(i < with.length) listComp.addComponent(with[i++]);
				else Bukkit.getLogger().warning("TellrawUtils ERROR: too few 'with' arguments for format text: "+formatText);

				textStart = nextSub + 2;//cut the %s
				nextSub = formatText.indexOf("%s", textStart);
			}
			final String s = formatText.substring(textStart).replace("<thingie_cuz_lazy>", "%");
			listComp.addComponent(s); // isFirstComp is guaranteed false by this point
			return listComp;
		}
		@Override protected String toStringInternal(){
			// For TranslationComponents that are actually just String formatters, convert to a list
			ListComponent listComp = attemptConvertToListComp();
			if(listComp != null) return listComp.toString();
			// Otherwise, proceed with toString() as a {"translate"} component
			String escapedJsonKey = TextUtils.escape(jsonKey, "\"","\n");
			StringBuilder builder = new StringBuilder().append("{\"translate\":\"").append(escapedJsonKey).append('"');
			if(fallback != null) builder.append(",\"fallback\":\"").append(TextUtils.escape(fallback, "\"","\n")).append('"');
			if(with != null && with.length > 0) builder.append(",\"with\":[").append(
					Arrays.stream(with).map(Component::toString).collect(Collectors.joining(","))).append(']');
			return builder.append(getProperties()).append('}').toString();
		}
		@Override TranslationComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new TranslationComponent(jsonKey, fallback, with, insert, click, hover, color, formats);
		}
	}

	// TODO: Split these into a TranslationUtils library? Try resolving toPlainText() for SelectorComponent using NMS?
	//------------------------------------------------------------------------
	final static String tropicalFishLocaleCCP = /*custom.tropical_fish.ccp*/"%s-%s %s";
	final static String tropicalFishLocaleCP = /*custom.tropical_fish.cp*/"%s %s";
	public static TranslationComponent getLocalizedDisplayNameForTropicalFish(int pccInt){
		Integer id = EntityUtils.commonTropicalFishIds.get(pccInt);
		if(id != null) return new TranslationComponent("entity.minecraft.tropical_fish.predefined."+id);
		net.evmodder.EvLib.extras.EntityUtils.PCC pcc = EntityUtils.PCCFromInt(pccInt);
		return pcc.bodyColor != pcc.patternColor
			? new TranslationComponent(tropicalFishLocaleCCP, new Component[]{
				new TranslationComponent("color.minecraft."+pcc.bodyColor.name().toLowerCase()),
				new TranslationComponent("color.minecraft."+pcc.patternColor.name().toLowerCase()),
				new TranslationComponent("entity.minecraft.tropical_fish.type."+pcc.pattern.name().toLowerCase())})
			: new TranslationComponent(tropicalFishLocaleCP, new Component[]{
					new TranslationComponent("color.minecraft."+pcc.bodyColor.name().toLowerCase()),
					new TranslationComponent("entity.minecraft.tropical_fish.type."+pcc.pattern.name().toLowerCase())});
	}
	public static TranslationComponent getBestGuessLocalizedDisplayName(EntityType eType){
		switch(eType){
			case MUSHROOM_COW: return new TranslationComponent("entity.minecraft.mooshroom");
			case SNOWMAN: return new TranslationComponent("entity.minecraft.snow_golem");
			case LEASH_HITCH: return new TranslationComponent("entity.minecraft.leash_knot");
			case MINECART_TNT: return new TranslationComponent("entity.minecraft.tnt_minecart");
			case MINECART_CHEST: return new TranslationComponent("entity.minecraft.chest_minecart");
			case MINECART_HOPPER: return new TranslationComponent("entity.minecraft.hopper_minecart");
			case MINECART_FURNACE: return new TranslationComponent("entity.minecraft.furnace_minecart");
			case MINECART_COMMAND: return new TranslationComponent("entity.minecraft.command_block_minecart");
			case MINECART_MOB_SPAWNER: return new TranslationComponent("entity.minecraft.spawner_minecart");
			default:
				return new TranslationComponent("entity.minecraft."+eType.name().toLowerCase()
						.replace("pig_zombie", "zombie_pigman"));
		}
	}
	public static Component getLocalizedDisplayName(Entity entity, boolean useDisplayName){
		if(entity.getName() != null) return new RawTextComponent(
				(entity instanceof Player && useDisplayName) ? ((Player)entity).getDisplayName() : entity.getName());
		switch(entity.getType()){
			case VILLAGER:
				return new TranslationComponent("entity.minecraft."+entity.getType().name().toLowerCase()+"."
						+((Villager)entity).getProfession().name().toLowerCase());
			case RABBIT:
				return new TranslationComponent(((Rabbit)entity).getRabbitType() == Rabbit.Type.THE_KILLER_BUNNY
					? "entity.minecraft.killer_bunny"
					: "entity.minecraft.rabbit");
			case TROPICAL_FISH:
				return getLocalizedDisplayNameForTropicalFish(EntityUtils.getPCCInt((TropicalFish)entity));
			default:
				return getBestGuessLocalizedDisplayName(entity.getType());
		}
	}
	@SuppressWarnings("deprecation")
	static String getVanillaPotionEffectTypeName(PotionEffectType type){
		switch(type.getName()){
			case "AWKWARD": return "awkward";
			case "FIRE_RESISTANCE": return "fire_resistance";
			case "INSTANT_DAMAGE": return "harming";
			case "INSTANT_HEAL": return "healing";
			case "INVISIBILITY": return "invisibility";
			case "JUMP": return "leaping";
			case "LEVITATION": return "levitation";
			case "LUCK": return "luck";
			case "MUNDANE": return "mundane";
			case "NIGHT_VISION": return "night_vision";
			case "POISON": return "poison";
			case "REGEN": return "regeneration";
			case "SLOWNESS": return "slowness";
			case "SLOW_FALLING": return "slow_falling";
			case "SPEED": return "swiftness";
			case "STRENGTH": return "strength";
			case "THICK": return "thick";
			case "TURTLE_MASTER": return "turtle_master";
			case "WATER": return "water";
			case "WATER_BREATHING": return "water_breathing";
			case "WEAKNESS": return "weakness";
			case "UNCRAFTABLE": default: return "empty";
		}
	}
	
	private static Method getGameProfileFromSkull = null, getGameProfileFromSkullMeta = null, getNameFromProfile = null;
	static{
		try{
			getGameProfileFromSkull = Class.forName("net.evmodder.EvLib.extras.HeadUtils").getMethod("getGameProfile", Skull.class);
			getGameProfileFromSkullMeta = Class.forName("net.evmodder.EvLib.extras.HeadUtils").getMethod("getGameProfile", SkullMeta.class);
			getNameFromProfile = Class.forName("com.mojang.authlib.GameProfile").getMethod("getName");
		}
		catch(ClassNotFoundException | NoSuchMethodException | SecurityException e){}
	}
	private static String getProfileName(Skull skull){
		if(getNameFromProfile != null && getGameProfileFromSkull != null){
			try{return (String)getNameFromProfile.invoke(getGameProfileFromSkull.invoke(null, skull));}
			catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e){}
		}
		return skull.getOwningPlayer().getName();
	}
	private static String getProfileName(SkullMeta meta){
		if(getNameFromProfile != null && getGameProfileFromSkull != null){
			try{return (String)getNameFromProfile.invoke(getGameProfileFromSkullMeta.invoke(null, meta));}
			catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException e){}
		}
		return meta.getOwningPlayer().getName();
	}
	public static TranslationComponent getLocalizedDisplayName(BlockState block){
		switch(block.getType()){
			case PLAYER_HEAD:
			case PLAYER_WALL_HEAD:
				//Bukkit.getLogger().warning("profile name: "+HeadUtils.getGameProfile((Skull)item.getItemMeta()).getName());
				return new TranslationComponent("block.minecraft.player_head.named", new RawTextComponent(getProfileName((Skull)block)));
			case BLACK_BANNER:
			case BLUE_BANNER:
			case BROWN_BANNER:
			case CYAN_BANNER:
			case GRAY_BANNER:
			case GREEN_BANNER:
			case LIGHT_BLUE_BANNER:
			case LIGHT_GRAY_BANNER:
			case LIME_BANNER:
			case MAGENTA_BANNER:
			case ORANGE_BANNER:
			case PINK_BANNER:
			case PURPLE_BANNER:
			case RED_BANNER:
			case WHITE_BANNER:
			case YELLOW_BANNER:
				return new TranslationComponent("block.minecraft.banner"+((Banner)block).getPattern(0).getPattern().name().toLowerCase()
						+"."+((Banner)block).getBaseColor().name().toLowerCase());
			default:
				return new TranslationComponent("block.minecraft."+block.getType().name().toLowerCase()); 
		}
	}
	@SuppressWarnings("deprecation")
	public static Component getLocalizedDisplayName(ItemStack item){
		if(item.hasItemMeta() && item.getItemMeta().hasDisplayName()) return new RawTextComponent(item.getItemMeta().getDisplayName());
		if(item.getType().isBlock()){
			if(item.hasItemMeta() && item.getItemMeta() instanceof BlockStateMeta){
				return getLocalizedDisplayName(((BlockStateMeta)item.getItemMeta()).getBlockState());
			}
			switch(item.getType()){
				case PLAYER_HEAD:
				case PLAYER_WALL_HEAD:
					//Bukkit.getLogger().warning("profile name: "+HeadUtils.getGameProfile((SkullMeta)item.getItemMeta()).getName());
					return new TranslationComponent("block.minecraft.player_head.named", new RawTextComponent(getProfileName((SkullMeta)item.getItemMeta())));
				default:
					return new TranslationComponent("block.minecraft."+item.getType().name().toLowerCase());
			}
		}
		switch(item.getType()){
			case POTION:
			case SPLASH_POTION:
			case LINGERING_POTION:
			case TIPPED_ARROW:
				return new TranslationComponent("item.minecraft."+item.getType().name().toLowerCase()+".effect."+(item.hasItemMeta()
								? getVanillaPotionEffectTypeName(((PotionMeta)item.getItemMeta()).getBasePotionData().getType().getEffectType())
								: "empty"
							));
			case SHIELD:
				if(item.hasItemMeta()) return new TranslationComponent("item.minecraft.shield."
						+((Banner)((BlockStateMeta)item.getItemMeta()).getBlockState()).getBaseColor().name().toLowerCase());
			case WRITTEN_BOOK:
				return new RawTextComponent(((BookMeta)item.getItemMeta()).getTitle());  // Cannot be JSON, only raw String (last checked: 1.20)
			default:
				return new TranslationComponent("item.minecraft."+item.getType().name().toLowerCase()); 
		}
	}
	//------------------------------------------------------------------------

	public final static class ScoreComponent extends Component{
		final Object selector;
		final Objective objective;
		String value; // Optional; overwrites output of score selector
		public ScoreComponent(Object selector, Objective objective){this.selector = selector; this.objective = objective;}
		public ScoreComponent(String name, Objective objective){this.selector = name; this.objective = objective;}
		public ScoreComponent(Object selector, Objective objective, String value,
				String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			super(insert, click, hover, color, formats);
			this.selector = selector;
			this.objective = objective;
			this.value = value;
		}
		//tellraw @a {"score":{"name":"@p","objective":"levels","value":"3333"}}

		@Override public String toPlainText(){
			String name = null;
			try{
				UUID uuid = UUID.fromString(selector.toString());
				name = Bukkit.getEntity(uuid).getName();
			}
			catch(IllegalArgumentException ex){};
			try{
				Class<?> clazz = Class.forName("net.evmodder.EvLib.extras.SelectorUtils.Selector");
				@SuppressWarnings("unchecked")
				Collection<Entity> entities = (Collection<Entity>)clazz.getMethod("resolve").invoke(selector);
				if(entities.size() > 1) return "ERROR: more than 1 entity matched with score selector!";
				if(entities.isEmpty()) return "";
				name = entities.iterator().next().getName();
			}
			catch(Exception ex){name = selector.toString();}
			if(name == null) return "";
			return ""+objective.getScore(name).getScore();
		}
		@Override protected String toStringInternal(){
			StringBuilder builder = new StringBuilder().append("\"score\":{\"name\":\"")
					.append(selector.toString()).append("\",\"objective\":\"").append(objective.getName()).append('"');
			if(value != null) builder.append(",\"value\":\"").append(TextUtils.escape(value, "\"","\n")).append('"');
			return builder.append('}').append(getProperties()).append('}').toString();
		}
		@Override ScoreComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new ScoreComponent(selector, objective, value, insert, click, hover, color, formats);
		}
	}
	public final static class SelectorComponent extends Component{
//		final Selector selector;
		final Object selector;
		final boolean useDisplayNameInToPlaintext;
		public SelectorComponent(Object selector){this.selector = selector; this.useDisplayNameInToPlaintext = true;}
		public SelectorComponent(UUID uuid){this.selector = uuid; this.useDisplayNameInToPlaintext = true;}
		public SelectorComponent(Object selector, boolean useDisplayName){this.selector = selector; useDisplayNameInToPlaintext = useDisplayName;}
		public SelectorComponent(Object selector, String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			super(insert, click, hover, color, formats);
			this.selector = selector; this.useDisplayNameInToPlaintext = true;
		}
//		public SelectorComponent(SelectorType type, SelectorArgument...arguments){this.selector = new Selector(type, arguments);}
		//tellraw @a {"selector":"@a"}

		@Override public String toPlainText(){
			Collection<String> names = null;
			try{
				UUID uuid = selector instanceof UUID ? (UUID)selector : UUID.fromString(selector.toString());
				Entity entity = Bukkit.getEntity(uuid);
				if(entity != null) names = Arrays.asList(getLocalizedDisplayName(entity, useDisplayNameInToPlaintext).toPlainText());
			}
			catch(IllegalArgumentException ex){};
			if(names == null) try{
				Class<?> clazz = Class.forName("net.evmodder.EvLib.extras.SelectorUtils.Selector");
				@SuppressWarnings("unchecked")
				Collection<Entity> entities = (Collection<Entity>)clazz.getMethod("resolve").invoke(selector);
				names = entities.stream().filter(e -> e != null)
						.map(e -> getLocalizedDisplayName(e, useDisplayNameInToPlaintext).toPlainText()).collect(Collectors.toList());
			}
			catch(Exception ex){names = Arrays.asList(selector.toString());}
			return String.join(ChatColor.GRAY+", "+ChatColor.RESET, names);
		}
		@Override protected String toStringInternal(){
			return new StringBuilder().append("{\"selector\":\"").append(TextUtils.escape(selector.toString(), "\"","\n"))
					.append(getProperties()).append("\"}").toString();
		}
		@Override SelectorComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new SelectorComponent(selector, insert, click, hover, color, formats);
		}
	}
	public final static class KeybindComponent extends Component{
		final Keybind keybind;
		public KeybindComponent(Keybind keybind){this.keybind = keybind;}
		public KeybindComponent(Keybind keybind, String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			super(insert, click, hover, color, formats);
			this.keybind = keybind;
		}
		//tellraw @a {"keybind":"of.key.zoom"}

		@Override public String toPlainText(){
			if(toPlainTextUseNMS()) try{
				Object translateComp = keybindConstructor.newInstance(keybind.toString());
				if(makeIChatMutableComponent != null) translateComp = makeIChatMutableComponent.invoke(null, translateComp);
				return (String)(chatMessageGetString.invoke(translateComp));
			}
			catch(IllegalAccessException | IllegalArgumentException | InvocationTargetException | InstantiationException e){}

			// This is ONLY correct when the key is invalid/unknown to the client
			return keybind.toString();
		}
		@Override protected String toStringInternal(){
			return new StringBuilder().append("{\"keybind\":\"").append(keybind).append('"').append(getProperties()).append('}').toString();
		}
		@Override KeybindComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new KeybindComponent(keybind, insert, click, hover, color, formats);
		}
	}

	//data modify entity @e[type=item,distance=..5,limit=1] Item.tag.display.Name set value '{"text":"ee"}'
	public enum NBTSource{BLOCK, ENTITY, STORAGE};
	public final static class NBTComponent extends Component{
		// TODO: check if interpret:true counts as a "property" (i.e., affects list descendants)

		final String nbt; // "Item.tag.display.Name"
//		final String block; //Eg: /tellraw @p {"nbt":"","block":"^ ~ 0"}
//		final Object entity; //Eg: /tellraw @p {"nbt":"Pos","entity":"@e[type=!player]"}
//		final String storage; // TODO: uhhhhhhhhh
		final NBTSource source; // which of the 3 above
		final String specifier; // the selector
		// interpret=true => use toPlainText() on selected values
		final boolean interpret; //Eg: /tellraw @p {"nbt":"CustomName","entity":"@e","interpret":true/false} => 'Grumm' vs '{"text":"Grumm"}'
		final RawTextComponent separator;

		public NBTComponent(String nbt, NBTSource source, Object specifier){
			this.nbt = nbt; this.source = source; this.specifier = specifier.toString();
			interpret = false;
			separator = new RawTextComponent(", ");
		}
		public NBTComponent(String nbt, NBTSource source, Object specifier, boolean interpret, RawTextComponent separator,
				String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			super(insert, click, hover, color, formats);
			this.nbt = nbt; this.source = source; this.specifier = specifier.toString(); this.interpret = interpret; this.separator = separator;
		}
		@Override public String toPlainText(){return "";} //TODO: resolve selector target(s) and join using separator
		@Override protected String toStringInternal(){
			StringBuilder builder = new StringBuilder()
					.append("{\"nbt\":\"").append(nbt).append("\",\"")
					.append(source.name().toLowerCase()).append("\":\"").append(specifier).append('"');
			if(interpret) builder.append(",\"interpret\":true");
			if(!separator.toString().equals("\", \"")) builder.append(",\"separator\":").append(separator.toString());
			return builder.append(getProperties()).append('}').toString();
		}
		@Override NBTComponent copyWithNewProperties(String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			return new NBTComponent(nbt, source, specifier, interpret, separator, insert, click, hover, color, formats);
		}
	}

	/**
	 * Creates a <code>RawTextComponent</code> with the same color and format properties as seen at the trailing end of the input String
	 * @param str The String from which to draw color/format properties by means of ChatColor.getLastColors(str)
	 * @return an empty text RawTextComponent with color and format properties defined
	 */
	public static RawTextComponent getTrailingColorAndFormatProperties(String str){
		String colorAndFormatsStr = ChatColor.getLastColors(str).replace("§", "");
		if(colorAndFormatsStr.isEmpty()) return new RawTextComponent(""); // no color/format properties
		final char colorChar = colorAndFormatsStr.charAt(0);
		String color = null;
		if(colorChar == 'x'){
			color = "#"+colorAndFormatsStr.substring(1, 7);
			colorAndFormatsStr = colorAndFormatsStr.substring(7);
		}
		else if(TextUtils.isSimpleColor(colorChar)){
			color = ChatColor.getByChar(colorChar).name().toLowerCase();
			colorAndFormatsStr = colorAndFormatsStr.substring(1);
		}
		final Map<Format, Boolean> formats = colorAndFormatsStr.chars().mapToObj(c -> Format.fromChar((char)c)).collect(Collectors.toMap(f -> f, f -> true));
		return new RawTextComponent(/*text=*/"", /*insert=*/null, /*click=*/null, /*hover=*/null, color, formats);
	}

	public final static class ListComponent extends Component{
		@Override String getInsertion(){return components.isEmpty() ? null : components.get(0).getInsertion();}
		@Override TextClickAction getClickAction(){return components.isEmpty() ? null : components.get(0).getClickAction();}
		@Override TextHoverAction getHoverAction(){return components.isEmpty() ? null : components.get(0).getHoverAction();}
		@Override public String getColor(){return components.isEmpty() ? null : components.get(0).getColor();}
		@Override public Map<Format, Boolean> getFormats(){return components.isEmpty() ? null : components.get(0).getFormats();}
		Component last = null;
		List<Component> components;
		public ListComponent(Component...components){
			this.components = new ArrayList<>();
			for(Component comp : components) addComponent(comp);
		}
		public boolean isEmpty(){return components.isEmpty();}

		private RawTextComponent textCompWithSameProperties(Component comp, String text){
			return new RawTextComponent(text, comp.getInsertion(), comp.getClickAction(), comp.getHoverAction(), comp.getColor(), comp.getFormats());
		}
		// Cannot merge inline hex colors
		private ChatColor getSimpleColor(String s){
			if(s == null) return ChatColor.RESET;
			try{return ChatColor.valueOf(s.toUpperCase());}
			catch(IllegalArgumentException ex){return null;}
		}
		private RawTextComponent concatenateTextComps(RawTextComponent a, RawTextComponent b){
			final String colorAndFormatsA = ChatColor.getLastColors(a.getRawText());
			final String colorAndFormatsB = TextUtils.getLeadingColorAndFormats(b.getRawText());
			final String colorB = TextUtils.stripFormatsOnly(colorAndFormatsB);

			final String targetColor = b.getColor() != null ? b.getColor() : getColor();
			final ChatColor simpleTargetColor = getSimpleColor(targetColor);

			String joinColor = "";
			if(colorB.isEmpty()){
				String colorA = TextUtils.stripFormatsOnly(colorAndFormatsA);
				if(colorA.isEmpty() ? targetColor != getColor() : !colorA.equals(targetColor)){
					if(targetColor == null) joinColor += ChatColor.RESET;
					else if(simpleTargetColor != null) joinColor += simpleTargetColor;
					else return null;
				}
			}
			String joinFormats = "";
			if(joinColor.isEmpty()){
				for(Format f : Format.values()){
					final boolean globalFormat = getFormats() != null && getFormats().getOrDefault(f, false);
					final boolean targetFormat = b.getFormats() != null && b.getFormats().containsKey(f) ? b.getFormats().get(f) : globalFormat;
	
					if(colorAndFormatsB.indexOf(f.toChar) == -1){//NOT in B
						if(colorAndFormatsA.indexOf(f.toChar) == -1//NOT from A or from globalFormat
								&& (!globalFormat || !TextUtils.stripColorsOnly(a.getRawText()).equals(a.getRawText()))){
							if(targetFormat) joinFormats += ChatColor.COLOR_CHAR+f.toChar;
						}
						else if(!targetFormat){
							if(targetColor == null) joinColor += ChatColor.RESET;
							else if(simpleTargetColor != null) joinColor += simpleTargetColor;
							else return null;
							joinFormats = ""; break;
						}
					}
				}
			}
			if(!joinColor.isEmpty()){
				for(Format f : Format.values()){
					final boolean globalFormat = getFormats() != null && getFormats().getOrDefault(f, false);
					final boolean targetFormat = b.getFormats() != null && b.getFormats().containsKey(f) ? b.getFormats().get(f) : globalFormat;
					if(targetFormat && colorAndFormatsB.indexOf(f.toChar) == -1) joinFormats += ChatColor.COLOR_CHAR+f.toChar;
				}
			}
			return textCompWithSameProperties(a, a.getRawText() + joinColor + joinFormats + b.getRawText());
		}

		/**
		 * Possibly adds a @component to this @ListComponent.
		 * The function may choose to ignore empty components, and merge adjacent text and translation components when possible.
		 * @param component The component to be added
		 * @return true if the component's contents were merged into this ListComponent
		 */
		public boolean addComponent(Component component){
			// Currently the 1st component is just properties, so we can delete it and move the properties to the new component
			if(components.size() == 1 && ChatColor.stripColor(last.toPlainText()).isEmpty() && last.isPropertiesSupersetOf(component)){
				components.set(0, last=component.copyWithNewProperties(
						last.getInsertion(), last.getClickAction(), last.getHoverAction(), last.getColor(), last.getFormats()));
				return true;
			}
			// Similar to above, we are unwilling to accept an empty component unless it is the first element (setting the list properties)
			if(ChatColor.stripColor(component.toPlainText()).isEmpty() && last != null) return false;

			if(component instanceof RawTextComponent && last != null){
				if(last instanceof RawTextComponent){
					if((components.size() == 1 && last.isPropertiesSupersetOf(component)) // Inheriting list's properties
						|| component.copyWithNewProperties( // The only properties we can safely change are color and formats.
							component.getInsertion(), component.getClickAction(), component.getHoverAction(), last.getColor(), last.getFormats())
						.samePropertiesAs(last)
					){
						RawTextComponent merged = concatenateTextComps((RawTextComponent)last, (RawTextComponent)component);
						if(merged != null) components.set(components.size()-1, last = merged);
					}
				}
			}
			else if(component instanceof TranslationComponent){
				// For TranslationComponents that are actually just String substitutions, not translation keys.
				ListComponent strFormatComp = ((TranslationComponent)component).attemptConvertToListComp();
				if(strFormatComp != null) return addComponent(strFormatComp);
			}
			else if(component instanceof ListComponent){
				if(((ListComponent)component).components.size() <= 1 || isPropertiesSupersetOf(component)){
					for(Component comp : ((ListComponent)component).components) addComponent(comp);
					return true;
				}
			}
			return components.add(last = component);
		}
		public boolean addComponent(String text){return addComponent(new RawTextComponent(text));}

		/**
		 * Loops through all RawTextComponents in this instance and replaces all occurances of @textToReplace with the @replacement component
		 * @param textToReplace The simple text from inside a RawTextComponent to search for
		 * @param replacement The component substituted in place of each instance of matching text
		 * @return true if one or more replacements occurred
		 */
		public boolean replaceRawTextWithComponent(final String textToReplace, final Component replacement){
			if(textToReplace.isEmpty()) return false;
			boolean updated = false;
			for(int i=0; i<components.size(); ++i){
				Component comp = components.get(i);
				if(comp instanceof ListComponent){
					if(((ListComponent)comp).replaceRawTextWithComponent(textToReplace, replacement)) updated = true;
				}
				if(comp instanceof RawTextComponent == false) continue;
				RawTextComponent txComp = (RawTextComponent) comp;
				final String text = txComp.getRawText();
				if(text.contains(textToReplace) == false) continue;
				final String replacementRawText = replacement instanceof RawTextComponent ? ((RawTextComponent)replacement).getRawText() : null;

				if(replacementRawText != null && txComp.isPropertiesSupersetOf(replacement)){
					components.set(i, textCompWithSameProperties(txComp, text.replace(textToReplace, replacementRawText)));
					continue;
				}
				int matchIdx = text.indexOf(textToReplace);
				String textBefore = text.substring(0, matchIdx);
				String textAfter = text.substring(matchIdx+textToReplace.length());
				boolean emptyBefore = (replacementRawText != null ? ChatColor.stripColor(textBefore) : textBefore).isEmpty();
				boolean emptyAfter = (replacementRawText != null ? ChatColor.stripColor(textAfter) : textAfter).isEmpty();
				// Necessary to prevent overriding this ListComponent's group properties
				if(i == 0 && emptyBefore && !this.samePropertiesAs(replacement)){components.add(0, textCompWithSameProperties(txComp, "")); i = 1;}

				Component thisReplacement = replacement;
				if(replacementRawText != null){
					if(emptyBefore) thisReplacement = textCompWithSameProperties(thisReplacement, textBefore + replacementRawText);
					if(emptyAfter) thisReplacement = textCompWithSameProperties(thisReplacement, replacementRawText + textAfter);
				}
				if(!emptyBefore){
					RawTextComponent propertiesAtReplacement = getTrailingColorAndFormatProperties(textBefore);
					if(!this.isPropertiesSupersetOf(propertiesAtReplacement)){
						ListComponent subListComp = new ListComponent();
						subListComp.addComponent(propertiesAtReplacement);
						subListComp.addComponent(thisReplacement);
						thisReplacement = subListComp;
					}
				}
				if(emptyBefore && emptyAfter){
					if(i == components.size()-1) last = thisReplacement;
					components.set(i, thisReplacement);
				}
				else if(emptyBefore){
					components.set(i, textCompWithSameProperties(txComp, textAfter));
					components.add(i, thisReplacement);
				}
				else if(emptyAfter){
					components.set(i, new RawTextComponent(textBefore));
					if(++i == components.size()) components.add(last = thisReplacement);
					else components.add(i, thisReplacement);
				}
				else{
					components.set(i, textCompWithSameProperties(txComp, textBefore));
					RawTextComponent textAfterComp = textCompWithSameProperties(txComp, textAfter);
					if(++i == components.size()){components.add(thisReplacement); components.add(last = textAfterComp);}
					else{components.add(i, textAfterComp); components.add(i, thisReplacement);}
				}
				updated = true;
			}
			return updated;
		}

		/** If the first component is properties-only and all those properties are overridden, then we can discard it. */
		private boolean canDiscardFirstComponent(){
			if(components.size() > 1 && ChatColor.stripColor(components.get(0).toPlainText()).isEmpty()
					&& components.get(1).overridesAllPropertiesOf(components.get(0))){
				for(int i=2; i<components.size(); ++i){
					if(!components.get(i).overridesAllPropertiesOf(components.get(1))) return false;
				}
				return true;
			}
			return false;
		}

		@Override public String toPlainText(){
			return components.stream().map(Component::toPlainText).collect(Collectors.joining());
		}
		@Override protected String toStringInternal(){
			if(canDiscardFirstComponent()) components.remove(0);
			switch(components.size()){
				case 0: return "\"\"";
				case 1: return components.get(0).toString();
				default: return new StringBuilder().append('[').append(
							components.stream().map(Component::toString).collect(Collectors.joining(","))
						).append(']').toString();
			}
		}
		@Override ListComponent copyWithNewProperties(
				String insert, TextClickAction click, TextHoverAction hover, String color, Map<Format, Boolean> formats){
			ListComponent newListComp = new ListComponent(new RawTextComponent("", insert, click, hover, color, formats));
			components.forEach(comp -> newListComp.addComponent(comp));
			return newListComp;
		}
	}

	// Convert String with hex color(s) -> ListComponent (because §x-style inline hex colors don't work in /tellraw)
	public final static ListComponent convertHexColorsToComponentsWithReset(String str){
		// §x§0§0§0§0§0§0 
		Matcher matcher = Pattern.compile("§x((?:§[0-9a-fA-F]){6})(?:[^§]|(?:§[k-o]))+").matcher(str);
		ListComponent comp = new ListComponent();
		int lastEnd = 0;
		while(matcher.find()){
			comp.addComponent(new RawTextComponent(str.substring(lastEnd, matcher.start())));
			String color = "#"+matcher.group(1).replace("§", "");
			comp.addComponent(new RawTextComponent(matcher.group().substring(14), /*insert=*/null, /*click=*/null, /*hover=*/null, color, /*formats=*/null));
			lastEnd = matcher.end();
		}
		comp.addComponent(new RawTextComponent(str.substring(lastEnd)));
		return comp;
	}

	private static class Pair<T, R>{
		public final T a; public final R b;
		public Pair(T t, R r){a=t; b=r;}
	}
	private final static Pair<String, Integer> parseColonThenSimpleString(String str, int i){
		while(Character.isWhitespace(str.charAt(i))) ++i;
		if(str.charAt(i) != ':'){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected : at index "+i+" of string: "+str);
			return null;
		}
		++i;
		while(Character.isWhitespace(str.charAt(i))) ++i;
		if(str.charAt(i) != '"'){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected \" at index "+i+" of string: "+str);
			return null;
		}
		int j = ++i;
		for(; str.charAt(j) != '"' || TextUtils.isEscaped(str, j); ++j);
		String simpleStr = str.substring(i, j);
		return new Pair<>(simpleStr, j + 1);
	}
	private final static Pair<Boolean, Integer> parseColonThenBoolean(String str, int i){
		while(Character.isWhitespace(str.charAt(i))) ++i;
		if(str.charAt(i) != ':'){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected : at index "+i+" of string: "+str);
			return null;
		}
		++i;
		while(Character.isWhitespace(str.charAt(i))) ++i;
		if(str.substring(i, i+4).toLowerCase().equals("true")) return new Pair<>(true, i+4);
		if(str.substring(i, i+5).toLowerCase().equals("false")) return new Pair<>(false, i+5);
		Bukkit.getLogger().warning("TellrawUtils ERROR: expected true/false at index "+i+" of string: "+str);
		return null;
	}
	private final static Pair<Component, Integer> parseListComponent(String str, int i, Component insert_comp0){
		//while(i < str.length() && Character.isWhitespace(str.charAt(i))) ++i;
		if(str.charAt(i) != '['){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected [ at index "+i+" of string: "+str);
			return null;
		}
		ListComponent listComp = new ListComponent();
		if(insert_comp0 != null) listComp.addComponent(insert_comp0);
		//TODO: Empty lists are not valid JSON (last checked: 1.20.4)
//		if(str.charAt(i+1) == ']') return new Pair<>(listComp, i + 1);
		do{
			++i;
			Pair<Component, Integer> nextComp = parseNextComponentFromString(str, i);
			if(nextComp == null || nextComp.a == null) return null;
			listComp.addComponent(nextComp.a);
			i = nextComp.b;
			while(Character.isWhitespace(str.charAt(i))) ++i;
		} while(str.charAt(i) == ',');
		if(str.charAt(i) != ']'){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected ] at index "+i+" of string: "+str);
			return null;
		}
		return new Pair<>(listComp, i + 1);
	}
	private final static Pair<Component[], Integer> parseComponentArrayForWith(String str, int i){
		//while(i < str.length() && Character.isWhitespace(str.charAt(i))) ++i;
		if(str.charAt(i) != '['){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected [ at index "+i+" of string: "+str);
			return null;
		}
		//TODO: Empty lists are valid for with:[]  (last checked: 1.20.4)
		if(str.charAt(i+1) == ']') return new Pair<>(new Component[0], i + 1); 
		List<Component> comps = new ArrayList<>();
		do{
			++i;
			Pair<Component, Integer> nextComp = parseNextComponentFromString(str, i);
			if(nextComp == null || nextComp.a == null) return null;
			comps.add(nextComp.a);
			i = nextComp.b;
			while(Character.isWhitespace(str.charAt(i))) ++i;
		} while(str.charAt(i) == ',');
		if(str.charAt(i) != ']'){
			Bukkit.getLogger().warning("TellrawUtils ERROR: expected ] at index "+i+" of string: "+str);
			return null;
		}
		return new Pair<>(comps.toArray(new Component[0]), i + 1);
	}
	enum ComponentType{TEXT, TRANSLATE, SCORE, SELECTOR, KEYBIND};
	private final static Pair<Component, Integer> parseNextComponentFromString(String str, int i){
		while(i < str.length() && Character.isWhitespace(str.charAt(i))) ++i;
		if(i == str.length()) return null;
		switch(str.charAt(i)){
			case '[':
				return parseListComponent(str, i, /*insert_comp0=*/null);
			case '"': {
				int j;
				for(j = ++i; str.charAt(j) != '"' || TextUtils.isEscaped(str, j); ++j);
				return new Pair<>(new RawTextComponent(str.substring(i, j)), j + 1);
			}
			case '{': {
				String insert = null;
				TextClickAction click = null;
				TextHoverAction hover = null;
				String color = null;
				TreeMap<Format, Boolean> formats = new TreeMap<>(); // Using TreeMap instead of HashMap because sorting is nice
				ComponentType type = null;
				String text = null;
				String jsonKey = null, fallback = null;
				Component[] with = null;
				Keybind keybind = null;
				Object selector = null;
				Objective objective = null;
				String value = null;
				//ListComponent extra = null;
				Integer extraListStart = null;
				do{ // while(str.charAt(i) != '}')
					++i;
					while(Character.isWhitespace(str.charAt(i))) ++i;
					if(str.charAt(i) != '"'){
						Bukkit.getLogger().warning("TellrawUtils ERROR parsing component at index "+i+" from string: "+str);
						return null;
					}
					++i;
					ComponentType newType = null;
					if(str.startsWith("extra\"", i)){
						i += 6;
						while(Character.isWhitespace(str.charAt(i))) ++i;
						if(str.charAt(i) != ':'){
							Bukkit.getLogger().warning("TellrawUtils ERROR: expected : at index "+i+" of string: "+str);
							return null;
						}
						++i;
						while(Character.isWhitespace(str.charAt(i))) ++i;
						extraListStart = i;
						Pair<Component, Integer> extraAndIdx = parseListComponent(str, i, /*insert_comp0*/null);
						if(extraAndIdx == null) return null;
						//extra = (ListComponent)extraAndIdx.a;
						i = extraAndIdx.b;
					}
					else if(str.startsWith("color\"", i)){
						i += 6;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						color = textAndIdx.a;
						i = textAndIdx.b;
					}
					else if(str.startsWith("bold\"", i)){
						i += 5;
						Pair<Boolean, Integer> boolAndIdx = parseColonThenBoolean(str, i);
						if(boolAndIdx == null) return null;
						formats.put(Format.BOLD, boolAndIdx.a);
						i = boolAndIdx.b;
					}
					else if(str.startsWith("italic\"", i)){
						i += 7;
						Pair<Boolean, Integer> boolAndIdx = parseColonThenBoolean(str, i);
						if(boolAndIdx == null) return null;
						formats.put(Format.ITALIC, boolAndIdx.a);
						i = boolAndIdx.b;
					}
					else if(str.startsWith("underlined\"", i)){
						i += 11;
						Pair<Boolean, Integer> boolAndIdx = parseColonThenBoolean(str, i);
						if(boolAndIdx == null) return null;
						formats.put(Format.UNDERLINED, boolAndIdx.a);
						i = boolAndIdx.b;
					}
					else if(str.startsWith("strikethrough\"", i)){
						i += 14;
						Pair<Boolean, Integer> boolAndIdx = parseColonThenBoolean(str, i);
						if(boolAndIdx == null) return null;
						formats.put(Format.STRIKETHROUGH, boolAndIdx.a);
						i = boolAndIdx.b;
					}
					else if(str.startsWith("obfuscated\"", i)){
						i += 11;
						Pair<Boolean, Integer> boolAndIdx = parseColonThenBoolean(str, i);
						if(boolAndIdx == null) return null;
						formats.put(Format.OBFUSCATED, boolAndIdx.a);
						i = boolAndIdx.b;
					}
					else if(str.startsWith("insertion\"", i)){
						i += 10;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						insert = textAndIdx.a;
						i = textAndIdx.b;
					}
					else if(str.startsWith("with\"", i)){
						i += 5;
						while(Character.isWhitespace(str.charAt(i))) ++i;
						if(str.charAt(i) != ':'){
							Bukkit.getLogger().warning("TellrawUtils ERROR: expected : at index "+i+" of string: "+str);
							return null;
						}
						++i;
						Pair<Component[], Integer> withAndIdx = parseComponentArrayForWith(str, i);
						if(withAndIdx == null) return null;
						with = withAndIdx.a;
						i = withAndIdx.b;
					}
					else if(str.startsWith("fallback\"", i)){
						i += 9;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						fallback = textAndIdx.a;
						i = textAndIdx.b;
					}
					// Content tags are checked in the order: text, translate, score, selector, keybind, nbt
					else if(str.startsWith("text\"", i)){
						newType = ComponentType.TEXT;
						i += 5;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						text = textAndIdx.a;
						i = textAndIdx.b;
					}
					else if(str.startsWith("translate\"", i)){
						newType = ComponentType.TRANSLATE;
						i += 10;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						jsonKey = textAndIdx.a;
						i = textAndIdx.b;
					}
					else if(str.startsWith("score\"", i)){
						newType = ComponentType.SCORE;
						i += 6;
						while(Character.isWhitespace(str.charAt(i))) ++i;
						if(str.charAt(i) != ':'){
							Bukkit.getLogger().warning("TellrawUtils ERROR: expected : at index "+i+" of string: "+str);
							return null;
						}
						++i;
						while(Character.isWhitespace(str.charAt(i))) ++i;
						if(str.charAt(i) != '{'){
							Bukkit.getLogger().warning("TellrawUtils ERROR: expected { at index "+i+" of string: "+str);
							return null;
						}
						do{
							++i;
							while(Character.isWhitespace(str.charAt(i))) ++i;
							if(str.charAt(i) != '"'){
								Bukkit.getLogger().warning("TellrawUtils ERROR: expected \" at index "+i+" of string: "+str);
								return null;
							}
							++i;
							if(str.startsWith("name\"", i)){
								i += 5;
								Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
								if(textAndIdx == null) return null;
								selector = TextUtils.unescapeString(textAndIdx.a);
								i = textAndIdx.b;
							}
							else if(str.startsWith("objective\"", i)){
								i += 10;
								Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
								if(textAndIdx == null) return null;
								objective = Bukkit.getServer().getScoreboardManager().getMainScoreboard().getObjective(
										TextUtils.unescapeString(textAndIdx.a));
								i = textAndIdx.b;
							}
							else if(str.startsWith("value\"", i)){
								i += 6;
								Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
								if(textAndIdx == null) return null;
								value = TextUtils.unescapeString(textAndIdx.a);
								i = textAndIdx.b;
							}
							while(Character.isWhitespace(str.charAt(i))) ++i;
						} while(str.charAt(i) == ',');
						if(str.charAt(i) != '}'){
							Bukkit.getLogger().warning("TellrawUtils ERROR: expected } at index "+i+" of string: "+str);
							return null;
						}
						++i;
					}
					else if(str.startsWith("selector\"", i)){
						newType = ComponentType.SELECTOR;
						i += 9;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						selector = TextUtils.unescapeString(textAndIdx.a);
						i = textAndIdx.b;
					}
					else if(str.startsWith("keybind\"", i)){
						newType = ComponentType.KEYBIND;
						i +=8;
						Pair<String, Integer> textAndIdx = parseColonThenSimpleString(str, i);
						if(textAndIdx == null) return null;
						String keybindStr = textAndIdx.a;
						for(Keybind k : Keybind.values()) if(k.toString().equals(keybindStr)) keybind = k;
						i = textAndIdx.b;
					}
					// TODO: else if(str.startsWith("nbt\"", i)){
					else{
						Bukkit.getLogger().warning("TellrawUtils ERROR: unknown comp-key at index "+i+" of : "+str);
						return null;
					}
					if(newType != null){
						if(type != null) Bukkit.getLogger().warning("TellrawUtils MULTIPLE-TYPES parsing component at index "+i+" from string: "+str);
						type = newType;
					}
					while(Character.isWhitespace(str.charAt(i))) ++i;
				} while(str.charAt(i) == ',');
				if(str.charAt(i) != '}'){
					Bukkit.getLogger().warning("TellrawUtils ERROR: expected } at index "+i+" of string: "+str);
					return null;
				}
				if(formats.isEmpty()) formats = null;
				Component comp = null;
				if(type == null){
					Bukkit.getLogger().warning("TellrawUtils UNKNOWN TYPE parsing component at index "+i+" from string: "+str);
					return null;
				}
				switch(type){
					case TEXT: comp = new RawTextComponent(text, insert, click, hover, color, formats); break;
					case TRANSLATE: comp = new TranslationComponent(jsonKey, fallback, with, insert, click, hover, color, formats); break;
					case SCORE: comp = new ScoreComponent(selector, objective, value, insert, click, hover, color, formats); break;
					case SELECTOR: comp = new SelectorComponent(selector, insert, click, hover, color, formats); break;
					case KEYBIND: comp = new KeybindComponent(keybind, insert, click, hover, color, formats); break;
				}
				++i;
				if(extraListStart == null) return new Pair<>(comp, i);
				else return new Pair<>(parseListComponent(str, extraListStart, comp).a, i);
			}
			default:
				Bukkit.getLogger().warning("TellrawUtils ERROR parsing component at index "+i+" from string: "+str);
				return null;
		}
	}
	public final static Component parseComponentFromString(String str){
		Pair<Component, Integer> compAndIdx = parseNextComponentFromString(str, 0);
		return compAndIdx == null ? null : compAndIdx.a;
	}
}